#!/bin/bash

# =========================================================
# Linux 通用开发环境一键安装脚本 V5.0 (安全加固版)
# 更新日志:
# V5.0: 引入 /etc/profile.d 管理环境变量，增加 Glibc 检测，优化 Python 安全安装
# =========================================================

# --- 全局配置 ---
LOG_DIR="/var/log"
LOG_PREFIX="dev_install_"
CURRENT_LOG_NAME="${LOG_PREFIX}$(date +%Y%m%d_%H%M%S).log"
LOG_FILE="${LOG_DIR}/${CURRENT_LOG_NAME}"
ENV_FILE="/etc/profile.d/z_dev_env_install.sh" # 环境变量配置文件

# --- 颜色定义 ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# --- 基础检查 ---
if [ "$EUID" -ne 0 ]; then
  echo -e "${RED}错误: 请使用 root 权限运行此脚本。${NC}"
  exit 1
fi

# 建立日志管道
exec 1> >(tee -a "$LOG_FILE")
exec 2>&1

# 架构判断
ARCH=$(uname -m)
case $ARCH in
  x86_64)  GO_ARCH="amd64"; NODE_ARCH="x64" ;;
  aarch64) GO_ARCH="arm64"; NODE_ARCH="arm64" ;;
  *)       echo -e "${RED}不支持的架构: $ARCH${NC}"; exit 1 ;;
esac

# =========================================================
# 核心工具函数
# =========================================================

# 1. 安全的环境变量管理
update_env_path() {
    local bin_path=$1
    local env_name=$2 # 可选，用于设置额外变量
    local env_val=$3  # 可选，变量值

    # 如果文件不存在，初始化
    if [ ! -f "$ENV_FILE" ]; then
        echo "# Generated by Dev Install Script V5.0" > "$ENV_FILE"
        chmod 644 "$ENV_FILE"
    fi

    # 添加 PATH (如果不存在)
    if ! grep -q "export PATH=.*$bin_path" "$ENV_FILE"; then
        # 将新路径放在最前面，确保优先使用新版本
        echo "export PATH=$bin_path:\$PATH" >> "$ENV_FILE"
        echo -e "${GREEN}路径已添加至环境变量: $bin_path${NC}"
    fi

    # 添加额外变量 (如 GOPROXY)
    if [ -n "$env_name" ] && [ -n "$env_val" ]; then
        if ! grep -q "export $env_name=" "$ENV_FILE"; then
            echo "export $env_name=$env_val" >> "$ENV_FILE"
        fi
    fi
}

# 2. 磁盘检查
check_disk_space() {
    local required_mb=$1
    local available_kb=$(df /usr/local | tail -1 | awk '{print $4}')
    local available_mb=$((available_kb / 1024))
    if [ "$available_mb" -lt "$required_mb" ]; then
        echo -e "${RED}磁盘空间不足! 需 ${required_mb}MB, 剩 ${available_mb}MB${NC}"
        return 1
    fi
    return 0
}

# 3. 下载函数
download_file() {
    local url=$1
    local filename=$2
    [ -z "$filename" ] && filename="${url##*/}"
    local retries=3
    
    echo -e "${BLUE}正在下载: $filename${NC}"
    while [ $retries -gt 0 ]; do
        wget --no-check-certificate --progress=bar:force:noscroll -O "$filename" "$url"
        [ $? -eq 0 ] && echo -e "${GREEN}下载完成${NC}" && return 0
        echo -e "${YELLOW}下载失败，剩余重试次数: $((retries-1))...${NC}"
        ((retries--))
        sleep 2
    done
    return 1
}

# 4. 版本检测
check_current_versions() {
    if command -v python3 >/dev/null 2>&1; then
        CUR_PY=$(python3 --version | awk '{print $2}')
        MSG_PY="${GREEN}${CUR_PY}${NC}"
    else
        MSG_PY="${RED}未安装${NC}"
    fi

    if command -v go >/dev/null 2>&1; then
        CUR_GO=$(go version | awk '{print $3}' | sed 's/go//')
        MSG_GO="${GREEN}${CUR_GO}${NC}"
    else
        MSG_GO="${RED}未安装${NC}"
    fi

    if command -v node >/dev/null 2>&1; then
        CUR_NODE=$(node -v)
        MSG_NODE="${GREEN}${CUR_NODE}${NC}"
    else
        MSG_NODE="${RED}未安装${NC}"
    fi
}

# 5. 系统依赖安装 (增强版)
install_deps() {
  if [ -z "$DEPS_INSTALLED" ]; then
    echo -e "${BLUE}正在检测系统并安装依赖...${NC}"
    
    if [ -f /etc/os-release ]; then
        . /etc/os-release
    else
        ID="unknown"
    fi

    case "$ID" in
        centos|rhel|fedora|rocky|almalinux|amzn)
            yum install -y wget curl git gcc make zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel libffi-devel xz jq
            ;;
        debian|ubuntu|kali)
            apt-get update
            apt-get install -y wget curl git gcc make zlib1g-dev build-essential libssl-dev libbz2-dev libreadline-dev libsqlite3-dev libncurses5-dev libncursesw5-dev xz-utils tk-dev libffi-dev liblzma-dev jq
            ;;
        *)
            echo -e "${YELLOW}警告: 无法识别的系统发行版 ($ID)，尝试通用安装...${NC}"
            yum install -y wget curl git gcc make || apt-get install -y wget curl git gcc make
            ;;
    esac
    export DEPS_INSTALLED=true
  fi
}

# =========================================================
# 安装逻辑
# =========================================================

install_python() {
  echo -e "\n${YELLOW}=== 安装 Python ===${NC}"
  check_disk_space 1000 || return
  
  # 镜像源选择
  MIRROR_URL="https://npmmirror.com/mirrors/python/"
  raw_versions=$(curl -s --connect-timeout 5 "$MIRROR_URL" | grep -oP 'href="3\.\d+\.\d+/"' | cut -d'"' -f2 | sed 's/\///g' | sort -V | tail -n 5)
  latest_ver=$(echo "$raw_versions" | tail -n 1)
  [ -z "$latest_ver" ] && latest_ver="3.11.8"
  
  echo -e "推荐版本: \n$(echo "$raw_versions" | awk '{print " - " $0}')"
  read -p "输入版本 (默认: $latest_ver): " py_version
  [ -z "$py_version" ] && py_version="$latest_ver"

  # 目录安全检查
  INSTALL_PATH="/usr/local/python3"
  
  cd /tmp
  download_file "${MIRROR_URL}${py_version}/Python-${py_version}.tgz" || return
  
  echo -e "${BLUE}解压并编译安装 (根据性能可能需要 5-20 分钟)...${NC}"
  tar -zxvf "Python-${py_version}.tgz" >/dev/null || return 1
  cd "Python-${py_version}" || return 1
  
  # 配置编译
  ./configure --enable-optimizations --prefix="$INSTALL_PATH" --with-ssl >/dev/null
  if [ $? -ne 0 ]; then echo -e "${RED}Configure 失败，请检查依赖${NC}"; return 1; fi

  make -j$(nproc) >/dev/null
  if [ $? -ne 0 ]; then echo -e "${RED}Make 编译失败${NC}"; return 1; fi
  
  # 关键安全点: 使用 altinstall 防止覆盖系统 /usr/bin/python3
  make altinstall >/dev/null
  
  # 建立软链接 (使用 distinct 名称避免冲突)
  ln -sf "${INSTALL_PATH}/bin/python3" /usr/bin/python3-new
  ln -sf "${INSTALL_PATH}/bin/pip3" /usr/bin/pip3-new
  
  # 配置 pip 源
  mkdir -p ~/.pip
  echo -e "[global]\nindex-url = https://mirrors.aliyun.com/pypi/simple/" > ~/.pip/pip.conf
  
  # 更新环境变量
  update_env_path "${INSTALL_PATH}/bin"

  echo -e "${GREEN}Python $py_version 安装成功!${NC}"
  echo -e "${YELLOW}提示: 系统默认 Python 未被覆盖。${NC}"
  echo -e "${YELLOW}1. 使用 'python3-new' 调用新版本${NC}"
  echo -e "${YELLOW}2. 或重新登录终端后，直接使用 'python3' (环境变量已优先生效)${NC}"
  
  cd /tmp && rm -rf "Python-${py_version}" "Python-${py_version}.tgz"
}

install_golang() {
  echo -e "\n${YELLOW}=== 安装 Golang ===${NC}"
  check_disk_space 500 || return

  # 获取版本
  json_data=$(curl -s --connect-timeout 5 "https://golang.google.cn/dl/?mode=json")
  if [ -n "$json_data" ]; then
    raw_versions=$(echo "$json_data" | jq -r '.[0:3] | .[].version' | sed 's/go//g')
    latest_ver=$(echo "$raw_versions" | head -n 1)
  else
    latest_ver="1.21.6"
  fi

  read -p "输入版本 (默认: $latest_ver): " go_version
  [ -z "$go_version" ] && go_version="$latest_ver"
  go_version=${go_version#v}; go_version=${go_version#go}

  cd /tmp
  download_file "https://mirrors.aliyun.com/golang/go${go_version}.linux-${GO_ARCH}.tar.gz" || return

  # 安全删除旧版本
  if [ -d "/usr/local/go" ]; then
      echo -e "${BLUE}清理旧版本 Golang...${NC}"
      rm -rf /usr/local/go
  fi

  tar -C /usr/local -xzf "go${go_version}.linux-${GO_ARCH}.tar.gz" || return 1
  
  # 更新环境变量和代理
  update_env_path "/usr/local/go/bin" "GOPROXY" "https://goproxy.cn,direct"
  
  echo -e "${GREEN}Golang $go_version 安装成功!${NC}"
  echo -e "${YELLOW}提示: 请运行 'source $ENV_FILE' 或重新登录以生效。${NC}"
  cd /tmp && rm -f "go${go_version}.linux-${GO_ARCH}.tar.gz"
}

install_nodejs() {
  echo -e "\n${YELLOW}=== 安装 Node.js ===${NC}"
  check_disk_space 300 || return

  # Glibc 版本检测 (防止 Node 18+ 在老系统报错)
  GLIBC_VER=$(ldd --version | head -n1 | awk '{print $NF}')
  echo -e "当前系统 Glibc 版本: ${BLUE}$GLIBC_VER${NC}"
  
  # 获取版本
  json_data=$(curl -s --connect-timeout 5 https://npmmirror.com/mirrors/node/index.json)
  if [ -n "$json_data" ]; then
    lts_ver=$(echo "$json_data" | jq -r 'map(select(.lts != false)) | .[0].version')
    curr_ver=$(echo "$json_data" | jq -r '.[0].version')
    echo -e "推荐: LTS=${GREEN}$lts_ver${NC}, 最新=${YELLOW}$curr_ver${NC}"
    default_ver=$lts_ver
  else
    default_ver="v18.19.0"
  fi

  read -p "输入版本 (默认: $default_ver): " node_version
  [ -z "$node_version" ] && node_version="$default_ver"
  if [[ $node_version != v* ]]; then v_node_version="v$node_version"; else v_node_version="$node_version"; fi

  # 再次确认兼容性
  major_ver=$(echo $v_node_version | cut -d'.' -f1 | sed 's/v//')
  if [ "$major_ver" -ge 18 ] && [ "$(echo "$GLIBC_VER < 2.28" | bc 2>/dev/null)" -eq 1 ]; then
      echo -e "${RED}警告: 您的 Glibc 版本过低 ($GLIBC_VER)，Node.js v18+ 需要 Glibc >= 2.28。${NC}"
      echo -e "${YELLOW}建议选择 Node.js v16.x 版本。${NC}"
      read -p "是否继续安装? [y/N]: " confirm
      [[ ! $confirm =~ ^[Yy]$ ]] && return
  fi

  cd /tmp
  download_file "https://npmmirror.com/mirrors/node/${v_node_version}/node-${v_node_version}-linux-${NODE_ARCH}.tar.xz" || return

  INSTALL_DIR="/usr/local/node"
  # 安全删除
  [ -d "$INSTALL_DIR" ] && rm -rf "$INSTALL_DIR"
  mkdir -p "$INSTALL_DIR"
  
  echo -e "${BLUE}解压中...${NC}"
  tar -xJf "node-${v_node_version}-linux-${NODE_ARCH}.tar.xz" -C "$INSTALL_DIR" --strip-components=1 || return 1

  # 建立软链接
  ln -sf $INSTALL_DIR/bin/node /usr/bin/node
  ln -sf $INSTALL_DIR/bin/npm /usr/bin/npm
  ln -sf $INSTALL_DIR/bin/npx /usr/bin/npx
  ln -sf $INSTALL_DIR/bin/corepack /usr/bin/corepack

  # 配置源
  $INSTALL_DIR/bin/npm config set registry https://registry.npmmirror.com
  
  # 更新环境变量
  update_env_path "$INSTALL_DIR/bin"

  echo -e "${GREEN}Node.js $v_node_version 安装成功!${NC}"
  cd /tmp && rm -f "node-${v_node_version}-linux-${NODE_ARCH}.tar.xz"
}

# =========================================================
# 日志管理系统 (保持原逻辑，略微优化交互)
# =========================================================
log_manager() {
    while true; do
        local log_count=$(ls -1 ${LOG_DIR}/${LOG_PREFIX}*.log 2>/dev/null | wc -l)
        local total_size=$(du -shc ${LOG_DIR}/${LOG_PREFIX}*.log 2>/dev/null | grep total | awk '{print $1}')
        [ -z "$total_size" ] && total_size="0K"

        echo -e "\n${CYAN}------- 日志管理系统 -------${NC}"
        echo -e "位置: ${LOG_DIR}"
        echo -e "统计: ${GREEN}${log_count}${NC} 个文件, 共 ${GREEN}${total_size}${NC}"
        echo "1. 查看最新日志"
        echo "2. 清理历史日志 (保留最近1个)"
        echo "3. 返回"
        read -p "请选择: " log_choice

        case $log_choice in
            1)
                latest_log=$(ls -t ${LOG_DIR}/${LOG_PREFIX}*.log 2>/dev/null | head -n 1)
                [ -f "$latest_log" ] && less "$latest_log" || echo "无日志"
                ;;
            2)
                ls -t ${LOG_DIR}/${LOG_PREFIX}*.log 2>/dev/null | tail -n +2 | xargs -r rm -f
                echo -e "${GREEN}清理完成${NC}"
                ;;
            3) return ;;
            *) echo -e "${RED}无效输入${NC}" ;;
        esac
    done
}

# =========================================================
# 主程序循环
# =========================================================
install_deps

while true; do
  check_current_versions

  echo -e "\n${BLUE}========================================${NC}"
  echo -e "   Linux 开发环境一键安装 V5.0 (安全加固版)"
  echo -e "   环境变量: ${CYAN}$ENV_FILE${NC}"
  echo -e "${BLUE}========================================${NC}"
  
  printf " 1. 安装 Python  [当前: %b]\n" "$MSG_PY"
  printf " 2. 安装 Golang  [当前: %b]\n" "$MSG_GO"
  printf " 3. 安装 Node.js [当前: %b]\n" "$MSG_NODE"
  echo   " 4. 日志管理"
  echo   " 5. 退出"
  echo -e "${BLUE}========================================${NC}"
  
  # 提示用户 source 文件
  if [ -f "$ENV_FILE" ]; then
      echo -e "${YELLOW}注意: 安装后请运行 'source $ENV_FILE' 以使环境生效${NC}"
  fi
  
  read -p "请输入选项 [1-5]: " choice

  case $choice in
    1) install_python ;;
    2) install_golang ;;
    3) install_nodejs ;;
    4) log_manager ;;
    5) echo "退出脚本"; exit 0 ;;
    *) echo -e "${RED}无效输入${NC}" ;;
  esac
done
